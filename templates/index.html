<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Prompt to 3D Model</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
  <header>
    <div class="container">
      <p class="eyebrow">Experiment</p>
      <h1>Generate quick 3D starters from a text prompt</h1>
      <p class="tagline">Sketch an idea in words and preview a printable STL instantly.</p>
    </div>
  </header>

  <main class="container">
    <section class="card grid">
      <div>
        <form id="prompt-form" class="stack">
          <label for="prompt">What should we build?</label>
          <textarea id="prompt" name="prompt" rows="6" placeholder="Example: A cylindrical pencil holder about 10cm tall with a wide base" required></textarea>

          <div class="hint">
            <p><strong>Try these:</strong></p>
            <ul>
              {% for idea in sample_prompts %}
              <li class="sample" data-idea="{{ idea }}">{{ idea }}</li>
              {% endfor %}
            </ul>
          </div>

          <button type="submit">Generate model</button>
        </form>
      </div>

      <div class="viewer-panel">
        <div class="viewer-header">
          <div>
            <p class="eyebrow">Preview</p>
            <h2 id="mesh-name">Waiting for a prompt…</h2>
            <p class="muted" id="mesh-details">Describe what you want to see the model preview here.</p>
          </div>
          <button id="download" type="button" class="secondary" disabled>Download STL</button>
        </div>
        <div class="viewer" id="viewer"></div>
        <div class="meta" id="mesh-meta"></div>
      </div>
    </section>
  </main>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { STLLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/STLLoader.js';

    const viewerEl = document.getElementById('viewer');
    const meshName = document.getElementById('mesh-name');
    const meshDetails = document.getElementById('mesh-details');
    const meshMeta = document.getElementById('mesh-meta');
    const downloadButton = document.getElementById('download');
    const form = document.getElementById('prompt-form');
    const promptField = document.getElementById('prompt');
    const sampleIdeas = document.querySelectorAll('.sample');

    let renderer, scene, camera, controls, stlLoader, currentObject, currentDownloadUrl;

    function setupScene() {
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(viewerEl.clientWidth, viewerEl.clientHeight);
      viewerEl.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      scene.background = new THREE.Color('#0b1224');

      camera = new THREE.PerspectiveCamera(35, viewerEl.clientWidth / viewerEl.clientHeight, 0.1, 100);
      camera.position.set(2.5, 1.6, 2.5);

      const ambient = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambient);

      const keyLight = new THREE.DirectionalLight(0xffffff, 0.6);
      keyLight.position.set(5, 5, 5);
      scene.add(keyLight);

      const rimLight = new THREE.DirectionalLight(0x22d3ee, 0.4);
      rimLight.position.set(-4, 6, -4);
      scene.add(rimLight);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      stlLoader = new STLLoader();

      window.addEventListener('resize', onResize);
      animate();
    }

    function onResize() {
      const { clientWidth, clientHeight } = viewerEl;
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(clientWidth, clientHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    function clearMesh() {
      if (currentObject) {
        scene.remove(currentObject);
        currentObject.geometry.dispose();
        currentObject.material.dispose();
        currentObject = null;
      }
    }

    function loadStlFromBase64(base64) {
      const binary = atob(base64);
      const array = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i += 1) {
        array[i] = binary.charCodeAt(i);
      }
      const blob = new Blob([array], { type: 'model/stl' });
      const url = URL.createObjectURL(blob);
      if (currentDownloadUrl) URL.revokeObjectURL(currentDownloadUrl);
      currentDownloadUrl = url;
      downloadButton.disabled = false;

      stlLoader.load(url, (geometry) => {
        clearMesh();
        geometry.computeVertexNormals();
        const material = new THREE.MeshStandardMaterial({
          color: 0x8ab4f8,
          metalness: 0.15,
          roughness: 0.35,
        });
        const mesh = new THREE.Mesh(geometry, material);
        geometry.center();
        const box = new THREE.Box3().setFromObject(mesh);
        const size = new THREE.Vector3();
        box.getSize(size);
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 1.5 / maxDim;
        mesh.scale.setScalar(scale);
        scene.add(mesh);
        currentObject = mesh;
        controls.reset();
        camera.position.set(2.5, 1.6, 2.5);
      });
    }

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      const prompt = promptField.value.trim();
      if (!prompt) return;

      meshName.textContent = 'Generating…';
      meshDetails.textContent = 'Building a mesh from your description.';
      meshMeta.textContent = '';
      downloadButton.disabled = true;

      const response = await fetch('/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt }),
      });

      const payload = await response.json();
      if (!response.ok) {
        meshName.textContent = 'Unable to generate model';
        meshDetails.textContent = payload.error || 'Try a different description.';
        return;
      }

      meshName.textContent = payload.mesh.name;
      meshDetails.textContent = payload.mesh.details;
      meshMeta.innerHTML = `
        <div><strong>Shape</strong><span>${payload.mesh.shape}</span></div>
        <div><strong>Faces</strong><span>${payload.mesh.faces}</span></div>
        <div><strong>Vertices</strong><span>${payload.mesh.vertices}</span></div>
        <div><strong>Bounds</strong><span>${payload.mesh.bounds.width.toFixed(2)} × ${payload.mesh.bounds.height.toFixed(2)} × ${payload.mesh.bounds.depth.toFixed(2)}</span></div>
      `;

      loadStlFromBase64(payload.stl);
    });

    downloadButton.addEventListener('click', () => {
      if (!currentDownloadUrl) return;
      const link = document.createElement('a');
      link.href = currentDownloadUrl;
      link.download = 'prompt-model.stl';
      document.body.appendChild(link);
      link.click();
      link.remove();
    });

    sampleIdeas.forEach((sample) => {
      sample.addEventListener('click', () => {
        promptField.value = sample.dataset.idea;
        promptField.focus();
      });
    });

    setupScene();
  </script>
</body>
</html>
